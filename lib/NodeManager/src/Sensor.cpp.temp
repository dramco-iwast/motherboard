/*  ____  ____      _    __  __  ____ ___
 * |  _ \|  _ \    / \  |  \/  |/ ___/ _ \
 * | | | | |_) |  / _ \ | |\/| | |  | | | |
 * | |_| |  _ <  / ___ \| |  | | |__| |_| |
 * |____/|_| \_\/_/   \_\_|  |_|\____\___/
 *                           research group
 *                             dramco.be/
 *
 *   KU Leuven - Technology Campus Gent,
 *   Gebroeders De Smetstraat 1,
 *   B-9000 Gent, Belgium
 *
 *         File: Sensor.cpp
 *      Created: 2018-05-02
 *       Author: Geoffrey Ottoy
 *      Version: 4.1
 *
 *  Description: Implementation of the Sensor class for interfacing with
 *    individual sensors.
 *
 *  Commissioned by Stillemans N.V.
 */


#include <Wire.h>

#include <Sensor.h>

#define POLL_RETRIES  2
#define POLL_ACK      0xAA

// Commands to interface with the sensors
#define CMD_POLL                    0x10 // see if a sensor responds
#define CMD_DEVICE_TYPE             0x20 // request the sensor device type
#define CMD_LED_TOGGLE              0x30 // request LED toggle (on the sensor)
#define CMD_GET_M_DATA_LEN          0x40 // check how many bytes/measurement we get from this sensor
#define CMD_GET_M_DATA              0x41 // get measurement
#define CMD_GET_C_DATA_LEN          0x50 // check how many bytes of control data we can send
#define CMD_SET_C_DATA              0x51 // send control bytes (e.g. treshold levels)
#define CMD_START_MEASUREMENT       0x60 // start a measurement
#define CMD_GET_READY               0x61 // check if sensor measurement data is ready

/******************************************************************************
 * Static functions (IIC communication)
 ******************************************************************************/

/* Internal function: reads data from a profile sensor using I2C.
 */
static bool readSensorData(uint8_t address, uint8_t command, uint8_t * data, uint8_t len){
  // Send command to specify the data that is being read
  Wire.beginTransmission(address);
  Wire.write(command);
  //delay(1); // give the device some time to return the data
  uint8_t stat = Wire.endTransmission();
  if(stat){
    /*Serial.print("addr: 0x");
    Serial.println(address, HEX);
    Serial.print("write (read) end transm.: ");
    Serial.println(stat);*/
    return false;
  }

  // Read the data returned by the device
  delay(5); // give the device some time to return the data

  Wire.requestFrom((uint8_t)address, (uint8_t)len);
  int i=len;

  while(Wire.available() && i--){
    *(data++) = Wire.read();
  }

  if(i){
    /*Serial.print("addr: 0x");
    Serial.println(address, HEX);
    Serial.print("read end. no more data: ");
    Serial.println(i);*/
    return false;
  }

  return true;
}

/* Internal function: writes data to a profile sensor using I2C.
 */
static bool writeSensorData(uint8_t address, uint8_t command, uint8_t * data, uint8_t len){
  Wire.beginTransmission(address);
  Wire.write(command);
  uint8_t stat = Wire.endTransmission();
  if(stat){
    return false;
  }

  if(len != 0){
    Wire.beginTransmission(address);
    Wire.write(data, len);
    stat = Wire.endTransmission();
  }

  if(stat){
    return false;
  }

  return true;
}

/******************************************************************************
 * Methods for individual Sensor manipulation
 ******************************************************************************/

/* General functionality ******************************************************/

/* Object constructor (basic initialization).
 */
Sensor::Sensor(void){
  this->_iicAddress = 0;
  this->_sensorType = 0;

  this->_mLen = 0;
  this->_cLen = 0;
  this->_mData = NULL;

  this->_info = "";
  this->_numErrors = 0;
  this->_dataChanged = false;
}

/* Poll the I2C bus to see if there's a sensor with an address "iicAddress".
 */
bool Sensor::pollAddress(uint8_t iicAddress){
  int retries = 0;
  uint8_t pollResponse = 0x00;
  do{ // POLL sensor
    if(readSensorData(iicAddress, CMD_POLL, &pollResponse, 1)){
      if(pollResponse==POLL_ACK){
        /*Serial.print("Sensor at address: 0x");
        Serial.println(iicAddress, HEX);*/
        
        return true;
      }
    }
    retries++;
    delay(20);
  } while (retries < POLL_RETRIES);
  
  return false;
}

bool Sensor::init(uint8_t iicAddress){
  // initialize address;
  this->_iicAddress = iicAddress;

  // request the sensor type (will update this->_sensorType )
  if(!this->requestSensorType()){
    // something went wrong
    return false;
  }

  // request the rx len (will update this->_mLen )
  if(!this->requestRxLen()){
    // something went wrong
    return false;
  }

  // request the tx len (will update this->_cLen )
  if(!this->requestTxLen()){
    // something went wrong
    return false;
  }

  // allocate memory to store rx data
  this->_mData = (uint8_t *) malloc(this->_mLen * sizeof(uint8_t));

  // generate info string
  char temp[80];
  sprintf(temp,
          "  - Address: 0x%02x\n  - Type:    0x%02x\n  - RxLen:   0x%02x\n  - TxLen:   0x%02x", 
          this->_iicAddress,
          this->_sensorType,
          this->_mLen,
          this->_cLen);

  this->_info = String(temp);

  return true;
}


/* Toggle the sensor's status LED (usefull for testing).
 */
bool Sensor::toggleLed(void){
  uint8_t ack = 0x00;
  if(!writeSensorData(this->_iicAddress, CMD_LED_TOGGLE, &ack, 1)){
    return false;
  }
  return (bool)(ack == POLL_ACK);
}

bool Sensor::startMeasurement(void){
  uint8_t ack = 0x00;
  if(!writeSensorData(this->_iicAddress, CMD_START_MEASUREMENT, &ack, 1)){
    return false;
  }
  return (bool)(ack == POLL_ACK);
}

bool Sensor::requestMeasurementData(void){
  // Wait until ready mechanism not implemented

  uint8_t tempData[this->_mLen];

  bool rv = readSensorData(this->_iicAddress, CMD_GET_M_DATA, tempData, this->_mLen);
  Serial.print("sensor->_mData:");
  for(uint8_t i=0; i<this->_mLen; i++){
    if(this->_mData[i] > 0x0F){
      Serial.print(" ");
    }
    else{
      Serial.print(" 0");
    }
    Serial.print(tempData[i], HEX);
  }
  Serial.println();

  // check if new data differs from old data and update if necessary
  if(memcmp(tempData, this->_mData, this->_mLen) != 0){
    this->_dataChanged = true;
    memcpy(this->_mData, tempData, this->_mLen);
  }
  else{
    this->_dataChanged = false;
  }

  return rv;
}

void Sensor::copyMeasurementData(uint8_t * buf, uint8_t len){
  uint8_t mLen = len;
  if(mLen > this->_mLen){
    mLen = this->_mLen;
  }
  for(uint8_t i=0; i<mLen; i++){
    *(buf+i) = *(this->_mData+i);
  }

  this->_dataChanged = false;
}

bool Sensor::writeControlData(uint8_t * buf, uint8_t len){
  if(len<this->_cLen){
    return writeSensorData(this->_iicAddress, CMD_SET_C_DATA, buf, len);
  }
 else{
    return writeSensorData(this->_iicAddress, CMD_SET_C_DATA, buf, this->_cLen);
  }
}


/* Access to sensor attributes ************************************************/

uint8_t Sensor::getIicAddress(void){
  return this->_iicAddress;
}

uint8_t Sensor::getSensorType(void){
  return this->_sensorType;
}

uint8_t Sensor::getRxLen(void){
  return this->_mLen;
}

uint8_t Sensor::getTxLen(void){
  return this->_cLen;
}

String Sensor::toString(void){
  return this->_info;
}

bool Sensor::dataChanged(void){
  return this->_dataChanged;
}

/* Private methods ************************************************************/

/* Request the sensor type and intialize the _sensorType attribute
 */
bool Sensor::requestSensorType(void){
  uint8_t devType = 0x00;
  int retries = 0;

  do{ // Read sensor type
    readSensorData(this->_iicAddress, CMD_DEVICE_TYPE, &devType, 1);
    if(devType != 0x00){
      this->_sensorType = devType;

      return true;
    }
    retries++;
    delay(5);
  } while (retries < POLL_RETRIES);

  return false;
}

bool Sensor::requestRxLen(void){
  uint8_t rxLen;
  if(!readSensorData(this->_iicAddress, CMD_GET_M_DATA_LEN, &rxLen, 1)){
    return false;
  }

  this->_mLen = rxLen;

  return true;
}
  
bool Sensor::requestTxLen(void){
  uint8_t txLen;
  if(!readSensorData(this->_iicAddress, CMD_GET_C_DATA_LEN, &txLen, 1)){
    return false;
  }

  this->_cLen = txLen;

  return true;
}
  
bool Sensor::checkReady(void){
  uint8_t ready = 0x00;
  if(!readSensorData(this->_iicAddress, CMD_GET_READY, &ready, 1)){
    Serial.println(ready, HEX);
    return false;
  }

  if(ready == 0x01){
    Serial.println(ready, HEX);
    return true;
  }

  return false;
}
